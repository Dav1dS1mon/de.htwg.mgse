/*
 * generated by Xtext 2.11.0
 */
grammar InternalSet;

options {
	superClass=AbstractInternalAntlrParser;
}

@lexer::header {
package org.xtext.de.htwg.parser.antlr.internal;

// Hack: Use our own Lexer superclass by means of import. 
// Currently there is no other way to specify the superclass for the lexer.
import org.eclipse.xtext.parser.antlr.Lexer;
}

@parser::header {
package org.xtext.de.htwg.parser.antlr.internal;

import org.eclipse.xtext.*;
import org.eclipse.xtext.parser.*;
import org.eclipse.xtext.parser.impl.*;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser;
import org.eclipse.xtext.parser.antlr.XtextTokenStream;
import org.eclipse.xtext.parser.antlr.XtextTokenStream.HiddenTokens;
import org.eclipse.xtext.parser.antlr.AntlrDatatypeRuleToken;
import org.xtext.de.htwg.services.SetGrammarAccess;

}

@parser::members {

 	private SetGrammarAccess grammarAccess;

    public InternalSetParser(TokenStream input, SetGrammarAccess grammarAccess) {
        this(input);
        this.grammarAccess = grammarAccess;
        registerRules(grammarAccess.getGrammar());
    }

    @Override
    protected String getFirstRuleName() {
    	return "PACK";
   	}

   	@Override
   	protected SetGrammarAccess getGrammarAccess() {
   		return grammarAccess;
   	}

}

@rulecatch {
    catch (RecognitionException re) {
        recover(input,re);
        appendSkippedTokens();
    }
}

// Entry rule entryRulePACK
entryRulePACK returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getPACKRule()); }
	iv_rulePACK=rulePACK
	{ $current=$iv_rulePACK.current; }
	EOF;

// Rule PACK
rulePACK returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			{
				newCompositeNode(grammarAccess.getPACKAccess().getPackPACKTYPEParserRuleCall_0());
			}
			lv_pack_0_0=rulePACKTYPE
			{
				if ($current==null) {
					$current = createModelElementForParent(grammarAccess.getPACKRule());
				}
				set(
					$current,
					"pack",
					lv_pack_0_0,
					"org.xtext.de.htwg.Set.PACKTYPE");
				afterParserOrEnumRuleCall();
			}
		)
	)
;

// Entry rule entryRulePACKTYPE
entryRulePACKTYPE returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getPACKTYPERule()); }
	iv_rulePACKTYPE=rulePACKTYPE
	{ $current=$iv_rulePACKTYPE.current; }
	EOF;

// Rule PACKTYPE
rulePACKTYPE returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			{ 
			  getUnorderedGroupHelper().enter(grammarAccess.getPACKTYPEAccess().getUnorderedGroup());
			}
			(
				(
		(
			{getUnorderedGroupHelper().canSelect(grammarAccess.getPACKTYPEAccess().getUnorderedGroup(), 0)}?=>(
				{
					getUnorderedGroupHelper().select(grammarAccess.getPACKTYPEAccess().getUnorderedGroup(), 0);
				}
							({true}?=>((
								{
									newCompositeNode(grammarAccess.getPACKTYPEAccess().getFormsFORMSParserRuleCall_0_0());
								}
								lv_forms_1_0=ruleFORMS
								{
									if ($current==null) {
										$current = createModelElementForParent(grammarAccess.getPACKTYPERule());
									}
									set(
										$current,
										"forms",
										lv_forms_1_0,
										"org.xtext.de.htwg.Set.FORMS");
									afterParserOrEnumRuleCall();
								}
							)
							))
				{ 
					getUnorderedGroupHelper().returnFromSelection(grammarAccess.getPACKTYPEAccess().getUnorderedGroup());
				}
			)
		)|
		(
			{getUnorderedGroupHelper().canSelect(grammarAccess.getPACKTYPEAccess().getUnorderedGroup(), 1)}?=>(
				{
					getUnorderedGroupHelper().select(grammarAccess.getPACKTYPEAccess().getUnorderedGroup(), 1);
				}
							({true}?=>((
								{
									newCompositeNode(grammarAccess.getPACKTYPEAccess().getUrlURLParserRuleCall_1_0());
								}
								lv_url_2_0=ruleURL
								{
									if ($current==null) {
										$current = createModelElementForParent(grammarAccess.getPACKTYPERule());
									}
									set(
										$current,
										"url",
										lv_url_2_0,
										"org.xtext.de.htwg.Set.URL");
									afterParserOrEnumRuleCall();
								}
							)
							))
				{ 
					getUnorderedGroupHelper().returnFromSelection(grammarAccess.getPACKTYPEAccess().getUnorderedGroup());
				}
			)
		)
				)+
				{getUnorderedGroupHelper().canLeave(grammarAccess.getPACKTYPEAccess().getUnorderedGroup())}?
			)
		)
			{ 
			  getUnorderedGroupHelper().leave(grammarAccess.getPACKTYPEAccess().getUnorderedGroup());
			}
	)
;

// Entry rule entryRuleFORMS
entryRuleFORMS returns [String current=null]:
	{ newCompositeNode(grammarAccess.getFORMSRule()); }
	iv_ruleFORMS=ruleFORMS
	{ $current=$iv_ruleFORMS.current.getText(); }
	EOF;

// Rule FORMS
ruleFORMS returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		{
			newCompositeNode(grammarAccess.getFORMSAccess().getFORM_ORIGINALParserRuleCall_0());
		}
		this_FORM_ORIGINAL_0=ruleFORM_ORIGINAL
		{
			$current.merge(this_FORM_ORIGINAL_0);
		}
		{
			afterParserOrEnumRuleCall();
		}
		    |
		{
			newCompositeNode(grammarAccess.getFORMSAccess().getFORM_DOCTORWHOParserRuleCall_1());
		}
		this_FORM_DOCTORWHO_1=ruleFORM_DOCTORWHO
		{
			$current.merge(this_FORM_DOCTORWHO_1);
		}
		{
			afterParserOrEnumRuleCall();
		}
		    |
		{
			newCompositeNode(grammarAccess.getFORMSAccess().getFORM_GAMEOFTHRONESParserRuleCall_2());
		}
		this_FORM_GAMEOFTHRONES_2=ruleFORM_GAMEOFTHRONES
		{
			$current.merge(this_FORM_GAMEOFTHRONES_2);
		}
		{
			afterParserOrEnumRuleCall();
		}
	)
;

// Entry rule entryRuleFORM_GAMEOFTHRONES
entryRuleFORM_GAMEOFTHRONES returns [String current=null]:
	{ newCompositeNode(grammarAccess.getFORM_GAMEOFTHRONESRule()); }
	iv_ruleFORM_GAMEOFTHRONES=ruleFORM_GAMEOFTHRONES
	{ $current=$iv_ruleFORM_GAMEOFTHRONES.current.getText(); }
	EOF;

// Rule FORM_GAMEOFTHRONES
ruleFORM_GAMEOFTHRONES returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	kw='{ "stark", "lennister", "targaryen" };'
	{
		$current.merge(kw);
		newLeafNode(kw, grammarAccess.getFORM_GAMEOFTHRONESAccess().getStarkLennisterTargaryenKeyword());
	}
;

// Entry rule entryRuleFORM_ORIGINAL
entryRuleFORM_ORIGINAL returns [String current=null]:
	{ newCompositeNode(grammarAccess.getFORM_ORIGINALRule()); }
	iv_ruleFORM_ORIGINAL=ruleFORM_ORIGINAL
	{ $current=$iv_ruleFORM_ORIGINAL.current.getText(); }
	EOF;

// Rule FORM_ORIGINAL
ruleFORM_ORIGINAL returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	kw='{ "ovally", "wave", "balk" };'
	{
		$current.merge(kw);
		newLeafNode(kw, grammarAccess.getFORM_ORIGINALAccess().getOvallyWaveBalkKeyword());
	}
;

// Entry rule entryRuleFORM_DOCTORWHO
entryRuleFORM_DOCTORWHO returns [String current=null]:
	{ newCompositeNode(grammarAccess.getFORM_DOCTORWHORule()); }
	iv_ruleFORM_DOCTORWHO=ruleFORM_DOCTORWHO
	{ $current=$iv_ruleFORM_DOCTORWHO.current.getText(); }
	EOF;

// Rule FORM_DOCTORWHO
ruleFORM_DOCTORWHO returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	kw='{ "tardis", "dalek", "cyberman" };'
	{
		$current.merge(kw);
		newLeafNode(kw, grammarAccess.getFORM_DOCTORWHOAccess().getTardisDalekCybermanKeyword());
	}
;

// Entry rule entryRuleURL
entryRuleURL returns [String current=null]:
	{ newCompositeNode(grammarAccess.getURLRule()); }
	iv_ruleURL=ruleURL
	{ $current=$iv_ruleURL.current.getText(); }
	EOF;

// Rule URL
ruleURL returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		{
			newCompositeNode(grammarAccess.getURLAccess().getURL_ORIGINALParserRuleCall_0());
		}
		this_URL_ORIGINAL_0=ruleURL_ORIGINAL
		{
			$current.merge(this_URL_ORIGINAL_0);
		}
		{
			afterParserOrEnumRuleCall();
		}
		    |
		{
			newCompositeNode(grammarAccess.getURLAccess().getURL_DOCTORWHOParserRuleCall_1());
		}
		this_URL_DOCTORWHO_1=ruleURL_DOCTORWHO
		{
			$current.merge(this_URL_DOCTORWHO_1);
		}
		{
			afterParserOrEnumRuleCall();
		}
		    |
		{
			newCompositeNode(grammarAccess.getURLAccess().getURL_GAMEOFTHRONESParserRuleCall_2());
		}
		this_URL_GAMEOFTHRONES_2=ruleURL_GAMEOFTHRONES
		{
			$current.merge(this_URL_GAMEOFTHRONES_2);
		}
		{
			afterParserOrEnumRuleCall();
		}
	)
;

// Entry rule entryRuleURL_GAMEOFTHRONES
entryRuleURL_GAMEOFTHRONES returns [String current=null]:
	{ newCompositeNode(grammarAccess.getURL_GAMEOFTHRONESRule()); }
	iv_ruleURL_GAMEOFTHRONES=ruleURL_GAMEOFTHRONES
	{ $current=$iv_ruleURL_GAMEOFTHRONES.current.getText(); }
	EOF;

// Rule URL_GAMEOFTHRONES
ruleURL_GAMEOFTHRONES returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	kw='/pack/got/'
	{
		$current.merge(kw);
		newLeafNode(kw, grammarAccess.getURL_GAMEOFTHRONESAccess().getPackGotKeyword());
	}
;

// Entry rule entryRuleURL_DOCTORWHO
entryRuleURL_DOCTORWHO returns [String current=null]:
	{ newCompositeNode(grammarAccess.getURL_DOCTORWHORule()); }
	iv_ruleURL_DOCTORWHO=ruleURL_DOCTORWHO
	{ $current=$iv_ruleURL_DOCTORWHO.current.getText(); }
	EOF;

// Rule URL_DOCTORWHO
ruleURL_DOCTORWHO returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	kw='/pack/dw/'
	{
		$current.merge(kw);
		newLeafNode(kw, grammarAccess.getURL_DOCTORWHOAccess().getPackDwKeyword());
	}
;

// Entry rule entryRuleURL_ORIGINAL
entryRuleURL_ORIGINAL returns [String current=null]:
	{ newCompositeNode(grammarAccess.getURL_ORIGINALRule()); }
	iv_ruleURL_ORIGINAL=ruleURL_ORIGINAL
	{ $current=$iv_ruleURL_ORIGINAL.current.getText(); }
	EOF;

// Rule URL_ORIGINAL
ruleURL_ORIGINAL returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	kw='/pack/original/'
	{
		$current.merge(kw);
		newLeafNode(kw, grammarAccess.getURL_ORIGINALAccess().getPackOriginalKeyword());
	}
;

RULE_ID : '^'? ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;

RULE_INT : ('0'..'9')+;

RULE_STRING : ('"' ('\\' .|~(('\\'|'"')))* '"'|'\'' ('\\' .|~(('\\'|'\'')))* '\'');

RULE_ML_COMMENT : '/*' ( options {greedy=false;} : . )*'*/';

RULE_SL_COMMENT : '//' ~(('\n'|'\r'))* ('\r'? '\n')?;

RULE_WS : (' '|'\t'|'\r'|'\n')+;

RULE_ANY_OTHER : .;
